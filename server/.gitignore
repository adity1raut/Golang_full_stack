# package main

# import (
# 	"context"
# 	"database/sql"
# 	"encoding/json"
# 	"github.com/golang-jwt/jwt/v5"
# 	"github.com/gorilla/handlers"
# 	"github.com/gorilla/mux"
# 	"golang.org/x/crypto/bcrypt"
# 	"log"
# 	_ "modernc.org/sqlite"
# 	"net/http"
# 	"strconv"
# 	"strings"
# 	"time"
# )

# var db *sql.DB
# var jwtKey = []byte("your-secret-key") // Change this in production

# // Models
# type User struct {
# 	ID        int       `json:"id"`
# 	Username  string    `json:"username"`
# 	Password  string    `json:"-"`
# 	Email     string    `json:"email"`
# 	Name      string    `json:"name"`
# 	Bio       string    `json:"bio"`
# 	CreatedAt time.Time `json:"created_at"`
# }

# type Todo struct {
# 	ID        int       `json:"id"`
# 	Task      string    `json:"task"`
# 	Status    bool      `json:"status"`
# 	UserID    int       `json:"user_id"`
# 	CreatedAt time.Time `json:"created_at"`
# }

# type ProfileResponse struct {
# 	Username  string    `json:"username"`
# 	Name      string    `json:"name"`
# 	Email     string    `json:"email"`
# 	Bio       string    `json:"bio"`
# 	CreatedAt time.Time `json:"created_at"`
# 	TodoCount int       `json:"todo_count"`
# }

# type Claims struct {
# 	UserID int `json:"user_id"`
# 	jwt.RegisteredClaims
# }

# func initDB() {
# 	var err error
# 	db, err = sql.Open("sqlite", "./todos.db")
# 	if err != nil {
# 		log.Fatal(err)
# 	}

# 	_, err = db.Exec("PRAGMA foreign_keys = ON")
# 	if err != nil {
# 		log.Fatal(err)
# 	}

# 	// Create tables with profile fields
# 	queries := []string{
# 		`CREATE TABLE IF NOT EXISTS users (
# 			id INTEGER PRIMARY KEY AUTOINCREMENT,
# 			username TEXT NOT NULL UNIQUE,
# 			password TEXT NOT NULL,
# 			email TEXT NOT NULL UNIQUE,
# 			name TEXT,
# 			bio TEXT,
# 			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
# 		);`,
# 		`CREATE TABLE IF NOT EXISTS todos (
# 			id INTEGER PRIMARY KEY AUTOINCREMENT,
# 			task TEXT NOT NULL,
# 			status BOOLEAN NOT NULL DEFAULT 0,
# 			user_id INTEGER NOT NULL,
# 			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
# 			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
# 		);`,
# 		`CREATE TABLE IF NOT EXISTS sessions (
# 			id INTEGER PRIMARY KEY AUTOINCREMENT,
# 			user_id INTEGER NOT NULL,
# 			token TEXT NOT NULL UNIQUE,
# 			expires_at DATETIME NOT NULL,
# 			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
# 		);`,
# 		"CREATE INDEX IF NOT EXISTS idx_todos_user_id ON todos(user_id);",
# 	}

# 	for _, query := range queries {
# 		_, err = db.Exec(query)
# 		if err != nil {
# 			log.Fatal(err)
# 		}
# 	}
# }

# // Auth Handlers
# func registerHandler(w http.ResponseWriter, r *http.Request) {
# 	var user struct {
# 		Username string `json:"username"`
# 		Password string `json:"password"`
# 		Email    string `json:"email"`
# 		Name     string `json:"name"`
# 	}

# 	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
# 		http.Error(w, "Invalid request body", http.StatusBadRequest)
# 		return
# 	}

# 	// Basic validation
# 	if user.Username == "" || user.Password == "" || user.Email == "" {
# 		http.Error(w, "Username, password, and email are required", http.StatusBadRequest)
# 		return
# 	}

# 	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
# 	if err != nil {
# 		http.Error(w, "Could not hash password", http.StatusInternalServerError)
# 		return
# 	}

# 	result, err := db.Exec(
# 		"INSERT INTO users (username, password, email, name) VALUES (?, ?, ?, ?)",
# 		user.Username, string(hashedPassword), user.Email, user.Name,
# 	)
# 	if err != nil {
# 		http.Error(w, "Username or email already exists", http.StatusConflict)
# 		return
# 	}

# 	userID, _ := result.LastInsertId()
# 	w.Header().Set("Content-Type", "application/json")
# 	w.WriteHeader(http.StatusCreated)
# 	json.NewEncoder(w).Encode(map[string]interface{}{
# 		"message": "User created successfully",
# 		"user_id": userID,
# 	})
# }

# func loginHandler(w http.ResponseWriter, r *http.Request) {
# 	var credentials struct {
# 		Username string `json:"username"`
# 		Password string `json:"password"`
# 	}

# 	if err := json.NewDecoder(r.Body).Decode(&credentials); err != nil {
# 		http.Error(w, "Invalid request body", http.StatusBadRequest)
# 		return
# 	}

# 	if credentials.Username == "" || credentials.Password == "" {
# 		http.Error(w, "Username and password are required", http.StatusBadRequest)
# 		return
# 	}

# 	var user User
# 	err := db.QueryRow(
# 		"SELECT id, username, password FROM users WHERE username = ?",
# 		credentials.Username,
# 	).Scan(&user.ID, &user.Username, &user.Password)
# 	if err != nil {
# 		http.Error(w, "Invalid username or password", http.StatusUnauthorized)
# 		return
# 	}

# 	if !CheckPasswordHash(credentials.Password, user.Password) {
# 		http.Error(w, "Invalid username or password", http.StatusUnauthorized)
# 		return
# 	}

# 	token, err := generateJWT(user.ID)
# 	if err != nil {
# 		http.Error(w, "Failed to generate token", http.StatusInternalServerError)
# 		return
# 	}

# 	expiresAt := time.Now().Add(24 * time.Hour)
# 	_, err = db.Exec(
# 		"INSERT INTO sessions (user_id, token, expires_at) VALUES (?, ?, ?)",
# 		user.ID, token, expiresAt,
# 	)
# 	if err != nil {
# 		http.Error(w, "Failed to create session", http.StatusInternalServerError)
# 		return
# 	}

# 	w.Header().Set("Content-Type", "application/json")
# 	json.NewEncoder(w).Encode(map[string]string{
# 		"token":   token,
# 		"message": "Logged in successfully",
# 	})
# }

# func logoutHandler(w http.ResponseWriter, r *http.Request) {
# 	authHeader := r.Header.Get("Authorization")
# 	if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
# 		http.Error(w, "Invalid authorization header", http.StatusBadRequest)
# 		return
# 	}

# 	token := strings.TrimPrefix(authHeader, "Bearer ")
# 	_, err := db.Exec("DELETE FROM sessions WHERE token = ?", token)
# 	if err != nil {
# 		http.Error(w, "Failed to logout", http.StatusInternalServerError)
# 		return
# 	}

# 	w.Header().Set("Content-Type", "application/json")
# 	w.WriteHeader(http.StatusOK)
# 	json.NewEncoder(w).Encode(map[string]string{
# 		"message": "Logged out successfully",
# 	})
# }

# // Profile Handlers
# func getProfileHandler(w http.ResponseWriter, r *http.Request) {
# 	userID := r.Context().Value("userID").(int)

# 	var profile ProfileResponse
# 	var todoCount int
# 	var name, bio sql.NullString

# 	// Get user info - handle NULL values properly
# 	err := db.QueryRow(`
# 		SELECT username, name, email, bio, created_at 
# 		FROM users WHERE id = ?
# 	`, userID).Scan(
# 		&profile.Username, &name, &profile.Email,
# 		&bio, &profile.CreatedAt,
# 	)
# 	if err != nil {
# 		http.Error(w, "User not found", http.StatusNotFound)
# 		return
# 	}

# 	// Handle NULL values
# 	if name.Valid {
# 		profile.Name = name.String
# 	}
# 	if bio.Valid {
# 		profile.Bio = bio.String
# 	}

# 	// Get todo count
# 	err = db.QueryRow(`
# 		SELECT COUNT(*) FROM todos WHERE user_id = ?
# 	`, userID).Scan(&todoCount)
# 	if err != nil {
# 		http.Error(w, "Failed to get todo count", http.StatusInternalServerError)
# 		return
# 	}

# 	profile.TodoCount = todoCount

# 	w.Header().Set("Content-Type", "application/json")
# 	json.NewEncoder(w).Encode(profile)
# }

# func updateProfileHandler(w http.ResponseWriter, r *http.Request) {
# 	userID := r.Context().Value("userID").(int)

# 	var update struct {
# 		Name *string `json:"name"`
# 		Bio  *string `json:"bio"`
# 	}
# 	if err := json.NewDecoder(r.Body).Decode(&update); err != nil {
# 		http.Error(w, "Invalid request body", http.StatusBadRequest)
# 		return
# 	}

# 	// Build dynamic update query
# 	var query strings.Builder
# 	var args []interface{}
# 	query.WriteString("UPDATE users SET ")

# 	if update.Name != nil {
# 		query.WriteString("name = ?")
# 		args = append(args, *update.Name)
# 	}

# 	if update.Bio != nil {
# 		if len(args) > 0 {
# 			query.WriteString(", ")
# 		}
# 		query.WriteString("bio = ?")
# 		args = append(args, *update.Bio)
# 	}

# 	if len(args) == 0 {
# 		http.Error(w, "No fields to update", http.StatusBadRequest)
# 		return
# 	}

# 	query.WriteString(" WHERE id = ?")
# 	args = append(args, userID)

# 	_, err := db.Exec(query.String(), args...)
# 	if err != nil {
# 		http.Error(w, "Failed to update profile", http.StatusInternalServerError)
# 		return
# 	}

# 	w.Header().Set("Content-Type", "application/json")
# 	w.WriteHeader(http.StatusOK)
# 	json.NewEncoder(w).Encode(map[string]string{
# 		"message": "Profile updated successfully",
# 	})
# }

# // Todo Handlers
# func getTodosHandler(w http.ResponseWriter, r *http.Request) {
# 	userID := r.Context().Value("userID").(int)

# 	rows, err := db.Query(`
# 		SELECT id, task, status, created_at 
# 		FROM todos WHERE user_id = ? ORDER BY created_at DESC
# 	`, userID)
# 	if err != nil {
# 		http.Error(w, "Failed to fetch todos", http.StatusInternalServerError)
# 		return
# 	}
# 	defer rows.Close()

# 	var todos []Todo
# 	for rows.Next() {
# 		var todo Todo
# 		if err := rows.Scan(&todo.ID, &todo.Task, &todo.Status, &todo.CreatedAt); err != nil {
# 			http.Error(w, "Failed to read todos", http.StatusInternalServerError)
# 			return
# 		}
# 		todo.UserID = userID
# 		todos = append(todos, todo)
# 	}

# 	// Return empty array instead of null if no todos
# 	if todos == nil {
# 		todos = []Todo{}
# 	}

# 	w.Header().Set("Content-Type", "application/json")
# 	json.NewEncoder(w).Encode(todos)
# }

# func createTodoHandler(w http.ResponseWriter, r *http.Request) {
# 	userID := r.Context().Value("userID").(int)

# 	var todo struct {
# 		Task string `json:"task"`
# 	}
# 	if err := json.NewDecoder(r.Body).Decode(&todo); err != nil {
# 		http.Error(w, "Invalid request body", http.StatusBadRequest)
# 		return
# 	}

# 	todo.Task = strings.TrimSpace(todo.Task)
# 	if todo.Task == "" {
# 		http.Error(w, "Task cannot be empty", http.StatusBadRequest)
# 		return
# 	}

# 	result, err := db.Exec(`
# 		INSERT INTO todos (task, user_id) VALUES (?, ?)
# 	`, todo.Task, userID)
# 	if err != nil {
# 		http.Error(w, "Failed to create todo", http.StatusInternalServerError)
# 		return
# 	}

# 	id, _ := result.LastInsertId()
# 	w.Header().Set("Content-Type", "application/json")
# 	w.WriteHeader(http.StatusCreated)
# 	json.NewEncoder(w).Encode(map[string]interface{}{
# 		"id":         id,
# 		"task":       todo.Task,
# 		"status":     false,
# 		"user_id":    userID,
# 		"created_at": time.Now(),
# 	})
# }

# func updateTodoHandler(w http.ResponseWriter, r *http.Request) {
# 	userID := r.Context().Value("userID").(int)
# 	vars := mux.Vars(r)
# 	todoID, err := strconv.Atoi(vars["id"])
# 	if err != nil {
# 		http.Error(w, "Invalid todo ID", http.StatusBadRequest)
# 		return
# 	}

# 	var update struct {
# 		Task   *string `json:"task"`
# 		Status *bool   `json:"status"`
# 	}
# 	if err := json.NewDecoder(r.Body).Decode(&update); err != nil {
# 		http.Error(w, "Invalid request body", http.StatusBadRequest)
# 		return
# 	}

# 	// Verify the todo belongs to the user
# 	var exists bool
# 	err = db.QueryRow(`
# 		SELECT EXISTS(SELECT 1 FROM todos WHERE id = ? AND user_id = ?)
# 	`, todoID, userID).Scan(&exists)
# 	if err != nil || !exists {
# 		http.Error(w, "Todo not found", http.StatusNotFound)
# 		return
# 	}

# 	// Build dynamic update query
# 	var query strings.Builder
# 	var args []interface{}
# 	query.WriteString("UPDATE todos SET ")

# 	if update.Task != nil {
# 		taskTrimmed := strings.TrimSpace(*update.Task)
# 		if taskTrimmed == "" {
# 			http.Error(w, "Task cannot be empty", http.StatusBadRequest)
# 			return
# 		}
# 		query.WriteString("task = ?")
# 		args = append(args, taskTrimmed)
# 	}

# 	if update.Status != nil {
# 		if len(args) > 0 {
# 			query.WriteString(", ")
# 		}
# 		query.WriteString("status = ?")
# 		args = append(args, *update.Status)
# 	}

# 	if len(args) == 0 {
# 		http.Error(w, "No fields to update", http.StatusBadRequest)
# 		return
# 	}

# 	query.WriteString(" WHERE id = ?")
# 	args = append(args, todoID)

# 	_, err = db.Exec(query.String(), args...)
# 	if err != nil {
# 		http.Error(w, "Failed to update todo", http.StatusInternalServerError)
# 		return
# 	}

# 	w.Header().Set("Content-Type", "application/json")
# 	w.WriteHeader(http.StatusOK)
# 	json.NewEncoder(w).Encode(map[string]string{
# 		"message": "Todo updated successfully",
# 	})
# }

# func deleteTodoHandler(w http.ResponseWriter, r *http.Request) {
# 	userID := r.Context().Value("userID").(int)
# 	vars := mux.Vars(r)
# 	todoID, err := strconv.Atoi(vars["id"])
# 	if err != nil {
# 		http.Error(w, "Invalid todo ID", http.StatusBadRequest)
# 		return
# 	}

# 	result, err := db.Exec(`
# 		DELETE FROM todos WHERE id = ? AND user_id = ?
# 	`, todoID, userID)
# 	if err != nil {
# 		http.Error(w, "Failed to delete todo", http.StatusInternalServerError)
# 		return
# 	}

# 	rowsAffected, _ := result.RowsAffected()
# 	if rowsAffected == 0 {
# 		http.Error(w, "Todo not found", http.StatusNotFound)
# 		return
# 	}

# 	w.Header().Set("Content-Type", "application/json")
# 	w.WriteHeader(http.StatusOK)
# 	json.NewEncoder(w).Encode(map[string]string{
# 		"message": "Todo deleted successfully",
# 	})
# }

# // Helpers
# func generateJWT(userID int) (string, error) {
# 	expirationTime := time.Now().Add(24 * time.Hour)
# 	claims := &Claims{
# 		UserID: userID,
# 		RegisteredClaims: jwt.RegisteredClaims{
# 			ExpiresAt: jwt.NewNumericDate(expirationTime),
# 		},
# 	}
# 	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
# 	return token.SignedString(jwtKey)
# }

# func CheckPasswordHash(password, hash string) bool {
# 	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
# 	return err == nil
# }

# func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
# 	return func(w http.ResponseWriter, r *http.Request) {
# 		authHeader := r.Header.Get("Authorization")
# 		if authHeader == "" {
# 			http.Error(w, "Authorization header missing", http.StatusUnauthorized)
# 			return
# 		}

# 		if !strings.HasPrefix(authHeader, "Bearer ") {
# 			http.Error(w, "Invalid authorization format", http.StatusUnauthorized)
# 			return
# 		}

# 		tokenString := strings.TrimPrefix(authHeader, "Bearer ")
# 		claims := &Claims{}

# 		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
# 			return jwtKey, nil
# 		})

# 		if err != nil || !token.Valid {
# 			http.Error(w, "Invalid token", http.StatusUnauthorized)
# 			return
# 		}

# 		// Check if token exists in sessions
# 		var exists bool
# 		err = db.QueryRow(`
# 			SELECT EXISTS(
# 				SELECT 1 FROM sessions 
# 				WHERE token = ? AND user_id = ? AND expires_at > datetime('now')
# 			)
# 		`, tokenString, claims.UserID).Scan(&exists)

# 		if err != nil || !exists {
# 			http.Error(w, "Invalid or expired session", http.StatusUnauthorized)
# 			return
# 		}

# 		// Add userID to context
# 		ctx := context.WithValue(r.Context(), "userID", claims.UserID)
# 		next.ServeHTTP(w, r.WithContext(ctx))
# 	}
# }

# func main() {
# 	initDB()
# 	defer db.Close()

# 	r := mux.NewRouter()

# 	corsMiddleware := handlers.CORS(
# 		handlers.AllowedOrigins([]string{"http://localhost:5173"}),
# 		handlers.AllowedMethods([]string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}),
# 		handlers.AllowedHeaders([]string{"Content-Type", "Authorization"}),
# 	)

# 	// Authentication routes
# 	r.HandleFunc("/register", registerHandler).Methods("POST")
# 	r.HandleFunc("/login", loginHandler).Methods("POST")
# 	r.HandleFunc("/logout", authMiddleware(logoutHandler)).Methods("POST")

# 	// Profile routes
# 	r.HandleFunc("/profile", authMiddleware(getProfileHandler)).Methods("GET")
# 	r.HandleFunc("/profile", authMiddleware(updateProfileHandler)).Methods("PUT")

# 	// Todo routes
# 	r.HandleFunc("/todos", authMiddleware(getTodosHandler)).Methods("GET")
# 	r.HandleFunc("/todos", authMiddleware(createTodoHandler)).Methods("POST")
# 	r.HandleFunc("/todos/{id}", authMiddleware(updateTodoHandler)).Methods("PUT")
# 	r.HandleFunc("/todos/{id}", authMiddleware(deleteTodoHandler)).Methods("DELETE")

# 	// Health check
# 	r.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
# 		w.Header().Set("Content-Type", "application/json")
# 		w.WriteHeader(http.StatusOK)
# 		json.NewEncoder(w).Encode(map[string]string{
# 			"status": "OK",
# 			"time":   time.Now().Format(time.RFC3339),
# 		})
# 	}).Methods("GET")

# 	log.Println("Server is running on port 8080")
# 	log.Fatal(http.ListenAndServe(":8080", corsMiddleware(r)))
# }

env 
database 
authHeader
Models